# 汇编语言程序设计笔记

## 汇编语言基础知识

本章是概念性章节，内容较少，直接列一个概念列表：


- 由冯 · 诺伊曼设计思想的计算机由五大部件组成：**运算器、控制器、存储器**、输入设备、输出设备。
- 数制：**二进制、八进制、十进制、十六进制**。
- 数制转换：低转高，乘权法；高转低，除基取余法。
- 数值的编码（计组的噩梦之一）：定点整数、原码、反码、补码、定点小数、浮点数。
- 数值编码：BCD码、ASCII码、Unicode编码。
- 寄存器：通用寄存器、段寄存器、指针寄存器、变址寄存器、控制寄存器、状态寄存器。
- 通用寄存器：数据寄存器（AX、BX、CX、DX）、指针寄存器（SP、BP）、变址寄存器（SI、DI）。
- 标志寄存器：状态标志（CF、PF、AF、ZF、SF）、控制标志（TF、IF、DF、OF）、*系统标志（NT、IOPL、VM、RF）*。
- 存储格式：
    - 数据的存储格式：小端方式（8086 采用的方式），低对低、高对高；大端方式：低对高、高对低。
    - 同一个地址既可以看作**字节单元**的地址，也可以看作**字单元**的地址，还可以看作**双字单元**的地址。                
- 存储器的分段管理：8086 把存储器分成若干段，每段的大小最大为 64KB，每个存储单元可表示为“段基地址：偏移地址”。**段基地址**是段的起始地址除以 16 后的值，即必须形如“XXXX0H”，**偏移地址**是段内偏移量，可以用 16 位表示。
- 段寄存器的作用：
    - CS：代码段寄存器，存放代码段的段基地址。指令寄存器 IP 存放指令的偏移地址，处理器利用 “CS:IP” 访问下一条指令。
    - SS：堆栈段寄存器，存放堆栈段的段基地址。堆栈指针 SP 存放栈顶的偏移地址，处理器利用 “SS:SP” 访问堆栈段。
    - DS：数据段寄存器，存放数据段的段基地址。
    - ES：附加段寄存器，附加的数据段，也用于数据的保存。
                    
- **（重要）寻址方式**：
    - 立即数寻址（立即寻址）：指令中直接给出操作数。
    - 寄存器寻址：指令中直接给出寄存器名。
    - 储存器寻址：**直接寻址**（指令中直接包含了有效地址，如：mov ax, [1000H]）；**寄存器间接寻址**（指令中给出寄存器名，寄存器中存放有效地址，如：mov ax, [bx]）；**寄存器相对寻址**(指令中给出寄存器名和偏移量，寄存器中存放基地址，如：mov ax, [bx+10H])；**基址变址寻址**（指令中给出基址寄存器、变址寄存器和偏移量，如：mov ax, [bx+si]）；**相对基址变址寻址**（指令中给出基址寄存器、变址寄存器、偏移量和段寄存器，如：mov ax, [bx+si+10H]）。
  - 隐含寻址方式
                                    


## 8086 的指令系统

**全几把是各种指令，简要记下有哪些，具体含义翻教材。**

- 数据传送指令：mov、xchg(reg &harr; reg/mem 或 reg/mem &harr; reg)、xlat(al &larr; ds:[bx+al])；
- 堆栈操作指令：push、pop（注意 push 的时候地址减少，pop 的时候地址增加）；
- 标志传送指令：lahf、sahf、pushf、popf；
- 地址传送指令：lea、lds、les；
- 算术运算指令：add、adc、inc、sub、sbb、dec、cmp
    - neg：用 0 减去操作数（会导致 `CF=1`），结果相当于按位取反加 1
    - mul r8(16)/m8(16),
        - ax &larr; al(x) * r8(16)/m8(16)
    - imul r8(16)/m8(16) 
        - ax &larr; al(x) * r8(16)/m8(16)
    - div r8(16)/m8(16)
        - al(ax) &larr; ax(dx.ax) 除 r8(16)/m8(16) 的商
        - ah(dx) &larr; ax(dx.ax) 除 r8(16)/m8(16) 的余数
    - idiv
- 符号拓展指令：cbw（拓展到 AX）、cwd（拓展到 DX）；
- 逻辑运算指令
    - 影响标志位：and、or、xor、test、neg
    - 不影响标志位：not
- 移位指令：shl、shr、sal、sar、rol、ror、rcl、rcr；
- 控制转移指令：jmp，太多了，可查 55 页表 2-3。
- 循环指令：loop、loopz、loopnz；
- 子程序指令：call（调用子程序）、ret（从子程序返回主程序）
- 中断指令：int（内部中断）、iret（外部中断）；


**状态标志**

- CF：进位标志，**无符号数运算时**，最高位是否有进位或借位。
- OF：溢出标志，**有符号数运算时**，运算结果是否超出范围。
- CF 和 OF 的区别：CF 表示无符号整数运算结果是否超出范围，超出范围后加上进位或借位运算结果依然**正确**；OF 表示有符号整数运算结果是否超出范围，超出范围后加上进位或借位运算结果**不正确**。
- SF：符号标志，结果的最高位。
- ZF：零标志，结果是否为 0。
- PF：奇偶标志，运算结果低八位中 1 的个数为 0 或者偶数时，PF=1；否则 PF=0。

- 判断是否影响标志位原则：是否发生了**算数、测试、比较、移数**，发生了往往是影响标志位的
- 特殊指令 `INC` 和 `DEC` 不会影响 `CF`。


**算术指令**

- 加法指令 ADD、ADC、INC
- 减法指令 SUB、SBB、DEC、NEG、CMP
- 乘法指令 MUL、IMUL
- 除法指令 DIV、IDIV


**符号拓展**

对于无符号数，高位置 0 即可拓展；对于有符号数，分别用 CBW 或 CWD 指令进行符号拓展。

**十进制调整指令**

为了实现在十六进制下进行十进制运算而进行的，比如 68h + 28h = 90h，执行 daa 后就会变成 96h，即十进制调整。

类似还有减法调整指令，das。还分压缩 BCD 码和非压缩 BCD 码，区别是前者用半个字节表示一个十进制位，而后者用一个字节表示一个十进制位。

**位操作指令**

- 逻辑运算指令 AND、OR、XOR、NOT、TEST(AND)
- 移位指令 SHL、SHR、SAL、SAR、ROL、ROR、RCL、RCR


**转移类指令**

- 无条件转移指令 JMP
- 利用 ZF：JZ、JE、JNZ、JNE
- 利用 SF：JS、JNS
- 利用 OF：JO、JNO
- 利用 PF：JP、JPE、JNP、JPO
- 利用 CF：JC、JB、JNAE、JNC、JNB、JAE
- 比较无符号数时用 Above 和 Blow，而有符号数时用 Greater 和 Less。
- 循环指令：LOOP(CX!=0)、LOOPZ/LOOPE(CX!=0 && ZF=1)、LOOPNZ/LOOPNE(CX!=0 && ZF=0)、JCXZ(CX!=0)


**子程序指令**

CALL、RET

**中断指令**

- 外部中断 
    - 可屏蔽中断
    - 非屏蔽中断
- 内部中断（亦称“异常”） 
- 除法错中断
- 指令中断
- 溢出中断
- 单步中断  
 

## 汇编语言程序格式

#### 程序格式

- 简化段定义

```asm
.model small
.stack
.data
    ; 数据定义
.code   
    .startup
    ; 代码定义
    .exit 0
end
```

- 完整段定义

```asm
stack segment stack
    ; 堆栈段定义
stack ends
data segment
    ; 数据定义
data ends
code segment
    assume cs:code, ds:data, ss:stack
start: ; 程序入口
    ; 程序代码    
    mov ax, 4c00h
    int 21h
code ends
    end start
```

![可执行文件的开发过程](1.png)

- 伪操作

| 伪操作名   | 格式               | 功能                 |  
|------------|--------------------|----------------------|  
| EQU        | 名字 EQU 表达式    | 给名字赋值           |  
| =          | 名字 = 表达式      | 同上，但允许重复赋值 |  
| LABEL      | 名字 LABEL 表达式  | 定义变量或标号的类型 |

- `LABEL` 的使用示例：

```asm
AGAINF LABEL FAR
AGAIN: PUSH BX
```


## 基本汇编语言程序设计

#### 串操作类指令

- 源操作数用寄存器 `SI` 间接寻址，默认在数据段 `DS` 中，即 `DS:[SI]`，允许段超越
- 目的操作数用寄存器 `DI` 间接寻址，默认在数据段 `ES` 中，即 `ES:[DI]`，不允许段超越
- 每执行一次串操作，源指针 `SI` 和目的指针 `DI` 都自动递增或递减

- 串传送
    - MOVSB es:[di] &larr; ds:[si], si &larr; si+1, di &larr; di+1
    - MOVSW es:[di] &larr; ds:[si], si &larr; si+2, di &larr; di+2
    - 常用重复前缀：REP
- 串存储
    - STOSB es:[di] &larr; al, di &larr; di+1
    - STOSW es:[di] &larr; ax, di &larr; di+2
    - 常用重复前缀：REP
- 串读取
    - LODSB al, ds:[si], si &larr; si+1
    - LODSW ax, ds:[si], si &larr; si+2
    - 常用重复前缀：REP
- 串比较
    - CMPSB ds:[si]-es:[di], si+1, di+1
    - CMPSW ds:[si]-es:[di], si+2, di+2
    - 常用重复前缀：REPZ
- 串扫描（用 `AL` 或 `AX` 的内容减去目的数据串，以比较两者的关系）
    - SCASB ; al-es:[di], di &larr; di$\pm$1
    - SCASW ; ax-es:[di], di &larr; di$\pm$2

#### 子程序的参数传递

寄存器传递、变量传递、栈传递

#### 子程序的嵌套、递归和重入

- 嵌套 子程序内包含有子程序的调用
- 递归 子程序调用自身
- 重入 子程序被中断后，又被终端服务程序所调用。能够重入的子程序称为*可重入子程序*。
- 子程序近调用时，入栈 2B，出栈 2B，而子程序远调用时，入栈 4B，出栈 4B。

## 高级汇编语言程序设计

#### 宏结构程序设计

- 定义

```asm
macro  macro_name arg1, arg2, ...
    ; 宏代码
endm
```

- 调用

```asm
macro_name arg1, arg2, ...
```

- 宏定义允许嵌套、递归
- 宏参数
    - 数量 $\in[0, +\infty)$，实际上肯定不是 $+\infty$，主要是我也不知道是多少
    - 类型 可以是常数、变量、存储单元、指令、表达式
    - 传参 使用 `&` 做变量替换。传字符串时有空格则要使用一对 `<>` 包裹。如果字符串中本身就有 `<>`，则使用 `!` 进行转义。传表达式时用 `%`，如 `%(1+2)`
    - 宏中的标号要加上 `local` 关键字
- 重复汇编
`repear` 型：
```asm
repeat count
    ; 重复执行的代码
endm
```
`for` 型：
```asm
for 形参, <实参表>
    ; 重复执行的代码
endm
```
`forc` 型：
```asm
forc 形参, 字符串
    ; 重复执行的代码
endm
```
- 条件汇编
```asm
ifxx expression
    ; 条件成立时执行的代码
[else
    ; 条件不成立时执行的代码]
endif
```

#### DOS 功能调用
- 步骤：
    - 将调用参数装入指定寄存器
    - 如需功能号，将它装入 `AH`
    - 如需子功能号，将它装入 `AL`
    - 按中断类型号调用 `DOS` 或 `BIOS` 中断（`DOS` 功能调用 `INT 21H` ）
    - 检查返回参数是否正确

## 32 位指令及其编程
- 实方式
    - 寻址 1MB 物理存储空间
    - 分段最大是 64KB
    - 可以使用 32 位寄存器和 32 位操作数
    - 可以采用 32 位寻址方式
- 保护方式
    - 具有段式存储管理功能
    - 具有页式存储管理功能
    - 寻址 4GB 物理存储空间

## 错题

---

1 设 CL=4，AL=0C8H，执行 SAR AL，CL 后，AL 中的数据是 【 0FCH 】

A、0FCH 

B、0CH 

C、08H 

D、0F8H

**解析** 注意是算数右移，而且是非循环的，所以 8 直接被丢弃了。又因为 C 是 1100，也就是符号位是 1，所以左边不停补 1。

---

2 比较两个字符串是否相等的指令可以是 【 REPZ CMPSB 】

A、REP CMPSB 

B、REPZ CMPSB 

C、RENPZ CMPSB 

D、REP MOVSB

正确答案是：**B、REPZ CMPSB**

**解析**：

- **`CMPSB`**：比较两个字符串的字节（Byte），即比较 `DS:SI` 和 `ES:DI` 指向的两个字节。
  - 如果两个字节相等，`ZF`（零标志位）被置为 1。
  - 如果不相等，`ZF` 被清零。
  - 比较完成后，`SI` 和 `DI` 自动递增或递减（取决于方向标志位 `DF` 的值）。

- **`REPZ`**：重复执行后续指令，直到满足以下条件之一：
  - **`ZF = 0`**（表示两个字节不相等）。
  - **`CX = 0`**（表示比较的字节数已达到指定长度）。

因此，`REPZ CMPSB` 的作用是：按字节逐一比较两个字符串，直到发现不相等的字节或比较完成。

- **A、REP CMPSB**：
  - `REP` 仅重复执行 `CMPSB`，直到 `CX = 0`，但不依赖 `ZF` 标志位。
  - 它无法在发现不相等时提前停止，因此不适合用于比较字符串是否相等。

- **B、REPZ CMPSB**：
  - `REPZ` 会在 `ZF = 0`（发现不相等）或 `CX = 0`（比较完成）时停止。
  - 这是比较两个字符串是否相等的正确指令。

- **C、RENPZ CMPSB**：
  - 选项中写作 `RENPZ`，但实际上没有这样的指令前缀。
  - 正确的前缀是 `REPNZ`，表示在 `ZF = 1` 时停止，适用于查找不相等的情况，而非比较字符串是否相等。

- **D、REP MOVSB**：
  - `REP MOVSB` 用于将字符串从源地址复制到目标地址，与字符串比较无关。

---