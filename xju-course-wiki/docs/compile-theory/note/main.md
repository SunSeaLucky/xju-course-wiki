---
markmap:
    maxWidth: 500
---

<style>
/* 初始化各级计数器 */
body { counter-reset: h1; }
h1 { counter-reset: h2; }
h2 { counter-reset: h3; }
h3 { counter-reset: h4; }
h4 { counter-reset: h5; }
h5 { counter-reset: h6; }

/* 每碰到一个标题，就累加对应计数器 */
h1 { counter-increment: h1; }
h2 { counter-increment: h2; }
h3 { counter-increment: h3; }
h4 { counter-increment: h4; }
h5 { counter-increment: h5; }
h6 { counter-increment: h6; }

/* 在标题前插入数字，如 2.3.1 */
h2::before { content: counter(h2) " "; }
h3::before { content: counter(h2) "." counter(h3) " "; }
/* …依次类推到 h6 */
</style>

# 编译原理笔记

## 引论<!-- markmap: fold -->

- **编译的基本概念**：把一种语言（源语言）书写的程序翻译成另一种语言（目标语言）的等价程序。
- 三种翻译程序的区别
- 编译的过程：源程序 -> 词法分析 -> 语法分析 -> 语义分析 -> 代码生成 -> 中间代码生成 -> 代码优化 -> 目标代码生成
    - 和所有阶段都有关系：表格管理、出错处理
    - 每个阶段的任务
        - 词法分析：将源程序分解成词素序列
        - 语法分析：将词素序列构造成语法树
        - 语义分析：检查语法树的语义正确性
        - 中间代码生成：将语义树转换成中间代码
        - 代码优化：对中间代码进行优化
        - 目标代码生成：将中间代码转换成目标代码
    - 每个阶段的输入、输出
        - 词法分析
            - 输入：源程序
            - 输出：单词序列
        - 语法分析
            - 输入：单词序列
            - 输出：语法树/语法短语/语法单位
        - 语义分析
            - 输入：语法树/语法短语/语法单位
            - 输出：语义树/语义短语/语义单位
        - 中间代码生成
            - 输入：语义树/语义短语/语义单位
            - 输出：中间代码
        - 代码优化
            - 输入：中间代码
            - 输出：优化后的中间代码
        - 目标代码生成
            - 输入：优化后的中间代码
            - 输出：目标代码
- 遍
- 趟
- 前端
- 后端

## 文法和语言<!-- markmap: fold -->

### 文法的直观概念

- 语言的指导规则

### 符号和符号串

- 定义
    - 字母表（符号集）：元素的非空有穷集合，字母表中的元素称为符号
    - 符号串：字母表中的符号组成的任何有穷序列称为符号串
- 符号串的运算：
    - 【不重要】符号串的头尾，固有头和固有尾
    - 连接
    - 方幂
- 符号串集合的运算
    - 乘积：$AB=\{xy|x\in A\wedge y\in B\}$
    - 闭包：$\sum^*=\sum^0\cup\sum^1\cup\cdots$
    - 正闭包：$\sum^+=\sum^1\cup\sum^2\cup\cdots$

### 文法和语言的形式定义

- **文法**：四元组 $(V_N, V_T, P, S)$，其中 $V_N$ 为非终结符集合，$V_T$ 为终结符集合，$P$ 为产生式集合，$S$ 为开始符号。$V_N \cap V_T = \phi$，$V_N \cup V_T = V$，$V$ 为所有符号集合。**语言的指导规则。**
- **规则**（重写规则、产生式、生成式）：是形如 $\alpha \rightarrow \beta$ 或 $\alpha ::= \beta$ 的 $(\alpha, \beta)$ 有序对，其中 $\alpha$ 为产生式左部，$\beta$ 为产生式右部。$\alpha \rightarrow \beta$ 或 $\alpha ::= \beta$ 读作 *定义为* 。
- **直接推导**：设 $\alpha \to \beta$ 是文法 $G=(V_N, V_T, P, S)$ 的规则，$\gamma$ 和 $\delta$ 是 $V^*$ 中的任意符号，若有符号串 $v, w$ 满足$v = \gamma \alpha \delta,~w = \gamma \beta \delta$，即说 $v$ 直接产生 $w$，或说 $v$ 是 $w$ 的直接推导，或说 $w$ 直接归约到 $v$，记作 $v \Rightarrow w$。
- **多步推导 $(\geq 1)$**：$v \xRightarrow{+} w$
- **多步推导 $(\geq 0)$**：$v \xRightarrow{*} w$
- **句型**：设 $G[S]$ 是一个文法，如果符号串 $x$ 是从识别符号推导出来的，即有 $S \Rightarrow x$，则称 $x$ 是文法 $G[S]$ 的句型。
- **句子**：若 $x$ 仅由终结符号组成，即 $S \Rightarrow x, x \in V_T^*$，则称 $x$ 为 $G[S]$ 的句子。
- **语言**：文法 $G$ 所产生的语言定义为集合 $\{x \mid S \xRightarrow{*} x, \text{其中 } S \text{ 为文法识别符号, 且 } x \in V_T^*\}$。可用 $L(G)$ 表示该集合。
- **等价文法**：若 $L(G1)=L(G2)$，则称这两个文法是等价的。



### 文法的类型

- **0 型文法**：设 $G = (V_N, V_T, P, S)$，如果它的每个产生式 $\alpha \rightarrow \beta$ 是这样一种结构：$\alpha \in (V_N \cup V_T)^*$ 且至少含有一个非终结符，而 $\beta \in (V_N \cup V_T)^*$，则 $G$ 是一个 0 型文法。
    - 直观理解：对于产生式限制最少的文法，基本意思就你是个产生式就行。所以，$x(x\geq1)$ 型文法，也都是 0 型文法。

- **1 型文法**：设 $G = (V_N, V_T, P, S)$ 为一个文法，若 $P$ 中的每一个产生式 $\alpha \rightarrow \beta$ 均满足 $|\beta| \geq |\alpha|$，仅仅 $S \rightarrow \varepsilon$ 除外，则文法 $G$ 是 1 型或**上下文有关的**（context-sensitive）。
    - 直观理解：每一步推导都会导致串非严格递增。

- **2 型文法**：设 $G = (V_N, V_T, P, S)$，若 $P$ 中的每一个产生式 $\alpha \rightarrow \beta$ 满足：$\alpha$ 是一个非终结符，$\beta \in (V_N \cup V_T)^*$，则此文法称为 2 型的或**上下文无关的**（context-free）。
    - 直观理解：在 0 型文法上增加了限制条件，左边必须是非终结符。
- **3 型文法**：设 $G = (V_N, V_T, P, S)$，若 $P$ 中的每一个产生式的形式都是 $A \rightarrow aB$ 或 $A \rightarrow a$，其中 $A$ 和 $B$ 都是非终结符，$a \in V_T^*$，则 $G$ 是 3 型文法或正规文法。
    - 直观理解：在 2 型文法上增加了限制条件，右边必须是终结符或终结符加非终结符的形式。由于这样的形式，正规文法是**没有左递归**的。

### 上下文无关文法（2 型）文法及其语法树

- 定义
    - 最左推导：如果在推导的任何一步 $\alpha \Rightarrow \beta$（$\alpha$、$\beta$ 是句型），都是对 $\alpha$ 中的最左非终结符进行替换，则称这种推导为最左推导。
    - 最右推导（规范推导）：如果在推导的任何一步 $\alpha \Rightarrow \beta$（$\alpha$、$\beta$ 是句型），都是对 $\alpha$ 中的最右非终结符进行替换，则称这种推导为最右推导。
    - 右句型（规范句型）：由规范推导所得的句型。
    - **二义**：一个文法存在某个句子，对应两颗不同的语法树。或者说，一个文法中存在某个句子，它有两个不同的最左（最右）推导
        - 文法的二义性和语言的二义是两个不同的概念。即 $\exists G, G'$，$G$ 是二义的，而 $G'$ 不是，但 $L(G)=L(G')$

### 句型的分析

- 自顶向下的分析方法
- 自低向上的分析方法
- 句型分析的有关问题
    - **短语**：一颗子树的所有叶子，自左至右排列，是相对于子树根的短语
    - **子树**：一颗语法树中的特有结点连同其全部后裔，以及联结后裔的边，以及这些节点的标记
    - 句柄：一个右句型的直接短语，称为该句型的句柄。无二义文法，一个右句型的唯一句柄是其所有直接短语中最左边的那一个

### 有关文法实际应用的一些说明

- 有害规则。形如 $U\rightarrow U$ 的产生式，有害是因为会引起文法的二义性
- 多余规则
    - 不可到达的
    - 不可终止的

## 词法分析<!-- markmap: fold -->

### 单词的形式化描述工具

- 正规文法
- 正规式（也成正则表达式，也是表示正规集的工具）
    - 正规式服从的代数规律如下
        - “或”的交换律
        - “或”的可结合律
        - “连接”的可分配律
        - 分配律
        - “或”的抽取律
- 正规文法和正规式的等价性
    - 正规文法到正规式的转换规则
        - $A\rightarrow xB,~B\rightarrow y \Leftrightarrow A= xy$
        - $A\rightarrow xA|y \Leftrightarrow A= x^*y$
        - $A\rightarrow Ay|x,~A=xy*$
        - $A\rightarrow x,~A\rightarrow y \Leftrightarrow A = x|y$

### 有穷自动机

- DFA
- NFA
- NFA 转化为 DFA（NFA 的确定化）
- DFA 的化简（DFA 的最小化）
- 正规式和 DFA 的等价性
- 正规文法和 DFA 的等价性

## 自顶向下的语法分析方法<!-- markmap: fold -->

### 确定的自顶向下分析思想

- 从文法的开始符号出发，考虑如何根据当前的输入符号唯一地确定选用哪个产生式替换相应非终结符以往下推导，或如何构造一棵相应的语法树
- FIRST
- FOLLOW
- SELECT
    - 若 $\alpha$ 无法经过 0 步或若干步推导得到 $\epsilon$，则 $SELECT(A\rightarrow \alpha)=FIRST(\alpha)$
    - 否则，$(FIRST(\alpha) - \{\epsilon\})\cup FOLLOW(A)$

### LL(1) 文法的判别

- 一个上下文无关文法是 $LL(1)$ 的充分必要条件是，对于每个非终结符 $A$ 的两个不同产生式，$SELECT(A\rightarrow \alpha)\cap SELECT(A\rightarrow \beta)=\phi$

### 某些非 $LL(1)$ 文法到 $LL(1)$ 文法的等价变换

- 提取左公共因子
- 消除左递归
    - 消除直接左递归
    - 消除间接左递归
    - 消除文法中一切左递归的文法
- $LL(1)$ 分析的实现
    - 表驱动的 $LL(1)$ 分析程序

## 自低向上优先分析<!-- markmap: fold -->

- 简单优先分析
    - 基本思想：对一个文法按一定的原则求出该文法的所有符号之间的优先关系，按照这种关系确定规约过程中的句柄，是规范规约
    - 优先关系定义
        - $X \doteq Y$ 当且仅当 G 中存在产生式规则 $A \rightarrow \dots XY \dots$。
        - $X \lessdot Y$ 当且仅当 G 中存在产生式规则 $A \rightarrow \dots XB \dots$，且 $B \Rightarrow^+ Y \dots$。
        - $X \gtrdot Y$ 当且仅当 G 中存在产生式规则 $A \rightarrow \dots BD \dots$，且 $B \Rightarrow^+ \dots X$ 和 $D \Rightarrow^* Y \dots$。
    - 简单优先文法定义
        - 在文法符号集 $V$ 中，任意两符号之间最多只有一种优先关系成立
        - 在文法中，任意两个产生式没有相同的右部
- 算符优先分析
    - 算符优先文法的定义
        - 如果文法 $G$ 中没有形如 $A\rightarrow ...BC...$ 的产生式，其中 $B$ 和 $C$ 为非终结符，则称 $G$ 为算符文法，也称 OG 文法
        - 三种算符优先关系
    - 算符优先分析表
        - FIRSTVT
        - LASTVT
    - 算符优先分析算法
        - 算符优先分析句型的性质
        - 最左素短语
    - 缺陷：只能分析表达式文法

## LR 分析<!-- markmap: fold -->

### LR 分析概述

实际上，LR 分析器就是一个**状态转换图**，分析表就是一个**状态转换表**。这与 DFA 是一致的。

- LR 分析器有 3 部分：
    - 总控程序（驱动程序），所有的 LR 分析器的总控程序都是相同的
    - 分析表（分析函数）
    - 分析栈

- 状态进行转换时，总共有四种转换类型：
    - 移进（Shift）
    - 规约（Reduce）
    - 接受（Accept）
    - 报错（Fail）

### LR(0) 分析

前面说，LR 分析本质上就是状态转换，因此，无论名字怎么变，也就是在状态转换上玩出花，不会有什么大的差异。

#### 可归前缀、活前缀

- 可归前缀：感觉就是规范句型中，可以进行规约的前缀
- 活前缀：若 $S' \xRightarrow[R]{} \alpha A \omega \xRightarrow[R]{} \alpha \beta \omega$ 是文法 $G$ 的扩广文法 $G'$ 中的一个规范推导，符号串 $\gamma$ 是 $\alpha\beta$ 的前缀，则称 $\gamma$ 是 $G$ 的一个活前缀。
- 把在规范句型中形成可归前缀之前，包括可归前缀在内的、所有前缀都称为活前缀。

#### LR(0) 项目集规范族的构造

- 状态转换图中，每个状态包含若干个项目。项目类型：
    - 移进项目。点后面是终结符的
    - 待约项目。点后面是非终结符
    - 归约项目。点后面啥也没有
    - 接受项目（规约项目的特殊情况）。既然是规约项目的特殊情况，它首先肯定是点后面啥也没有，其次则是要满足左部的非终结符为拓广产生式 $S'$
- 这种问题都要构造 DFA 和 LR 分析表。
- DFA 构造步骤：
    - 对开始符拓广。
    - 构建开始状态。构建步骤：
        - 写下状态可以得到的产生式，注意点的位置
        - 如果点后有非终结符，则写下对应非终结符的产生式
        - 重复 2，直至项目集不再扩大
    - 从开始状态，逐个输入可能输入的符号，每输入一个符号。使用上述构建步骤构建一次状态，直到项目集不再扩大。
- LR 分析表构造步骤：
    - 横轴是所有符号，终结符放一起（ACTION），非终结符放一起（GOTO）
    - 纵轴是所有 DFA 中所有状态的编号。对于状态 S 和符号 G，（S,G）代表状态 S 输入符号 G 后的状态，自然对应之前说的移进、规约、接受、报错四种。
    - 移进：$S_{移进的状态编号}$
    - 规约：规约进入的状态编号
    - 接受：acc
    - 报错：空白

### SLR(1) 分析

### LR(1) 分析

- LR(1) 项目集族的构造
- LR(1) 分析表的构造

### LALR(1) 分析

### 二义性文法在 LR 分析中的应用

## 语法制导的语义计算<!-- markmap: fold -->

### 基于属性文法的语义计算

- 在文法 $G[S]$ 基础上，为文法符号关联有特定意义的属性，并为产生式关联相应的语义动作/语义子程序/条件谓词，称之为属性文法，并称文法 $G[S]$ 是这一属性文法的基础文法

## 静态语义分析和中间代码生成<!-- markmap: fold -->

### 符号表

- 符号表的作用：
    - 在语义分析中，符号表所登记的内容是进行上下语义合法性检查的依据，检查标识符属性在上下文中的一致性和合法性

### 静态语义分析

- 静态语义刻画程序在静态一致性或完整性的方面，而动态语义刻画程序执行时的行为
- 静态语义分析的任务：
    - 控制流检查
    - 唯一性检查
    - 名字的上下文和相关性检查
    - 类型检查
- 中间代码生成
    - 中间代码是源程序的不同表现形式，也称为中间表示
    - 中间代码的作用
        - 用于源语言和目标语言之间的桥梁，避开二者之间较大的语义跨度
        - 利于编译程序的重定向
        - 利于进行与目标机无关的优化
- 常见的中间表示形式
    - AST，抽象语法树
    - DAG，抽象语法树的改进形式
    - TAC，三地址代码
    - P-code
    - Bytecode
    - SSA
- 三种考试要考的中间代码
    - 逆波兰式
    - 三元
    - 四元

## 运行时存储组织<!-- markmap: fold -->

- 概述
    - 问题：编译程序在生成目标程序之前应该合理安排好目标程序在逻辑地址空间中存储资源的使用
    - 存储空间布局
        - ![alt text](image-1.png)
        - 保留地址区。专门为目标机体系结构和操作系统保留的内存地址区
        - 代码区。静态存放编译程序产生的目标代码
        - 静态数据区。静态存放全局数据
        - 共享库和分别编译模块区。静态存放共享模块和分别编译模块的代码和全局数据
        - 动态数据区。运行时动态变化的 **堆区** 和 **栈区**
    - 存储分配策略
        - 静态存储分配。在编译期间为数据对象分配存储空间。这要求在编译期间就可确定数据对象的大小，同时还可以确定数据对象的数目
        - 栈式存储分配。在编译期间，过程、函数以及嵌套程序块的活动记录大小（最大值）应该是可以确定的（以便进入的时候动态地分配活动记录的空间），这是进行栈式存储分配的必要条件，如果不满足，则应该使用堆式存储分配
        - 堆式存储分配。当数据对象的生存期与创建它的过程/函数的执行期无关时，某些数据对象可能在该过程/函数结束之后仍然长期存在，就不适合机进行栈式存储分配。一种灵活但是较昂贵的存储分配方式是堆式存储分配
- 过程调用的传值和传址

## 代码优化和目标代码生成<!-- markmap: fold -->

- 编译过程的最后阶段的工作是目标代码生成，其**输入是某一种中间代码（如三地址码）以及符号表等信息，输出是特定目标机或虚拟机的目标代码**

### 基本块、流图和循环

- 基本块的划分

### 代码优化技术

- 窥孔优化
    - 删除冗余的存取
    - 常量合并
    - 常量传播
    - 代数化简
    - 控制流优化
    - 死代码删除
    - 强度削弱
    - 使用目标机惯用指令
- 局部优化
    - 构建 DAG 图
- 循环优化
    - 循环不变量外提
    - 归纳变量删除
- 全局优化

### 目标代码生成技术

- 问题：包括指令选择、寄存器分配、指令调度
- 指令选择
    - 为每条中间语言语句选择恰当的目标机指令或指令序列
- 寄存器分配。在生成的代码中，尽可能多地、有效地利用寄存器非常重要
    - 分配期间。为程序的某一点选择驻留在寄存器中的一组变量
    - 指派期间，挑出变量将要驻留的具体寄存器，即寄存器赋值
    - 在基本块范围内的寄存器分配称为局部寄存器分配，在过程范围内的寄存器分配称为过程级寄存器分配/全局寄存器分配
- 指令调度。指对指令的执行顺序进行适当的调整，从而使得整个程序得到优化的执行效果

## 🔥 老师上课给出的一些问题<!-- markmap: fold -->

**据老师说，能让你从 80 到 90。**

### 第一章

- 用 <u>BNF/EBNF</u> 或<u>语法图</u>描述高级语言
- 程序设计语言的定义涉及：<u>语法、语义、语用</u>
- 程序设计语言的形式语言涉及：<u>语法、语义</u>
- 在使用高级语言编程时，首先可通过编译程序发现源程序的<u>全部语法错误</u>和<u>部分语义错误</u>
- 编程语言的语言处理程序是一种<u>系统软件</u>
- 【存疑】什么是两类程序语言处理程序：<u>编译程序、解释程序</u>
- 【存疑】三种翻译程序：<u>汇编程序、编译程序、解释程序</u>
- 下面关于解释程序的描述正确的是 <u>(1)</u>。
    - (1) 解释程序的特点是处理程序时不产生目标代码
    - (2) 解释程序适用于 COBOL 和 FORTRAN 语言
    - (3) 解释程序是为打开编译程序技术的僵局而开发的
- 由于受到具体机器主存容量的限制，编译程序几个不同阶段的工作往往被组合成<u>D</u>。
    - A、过程  
    - B、程序  
    - C、批量  
    - D、遍  
- 编译的6个阶段 这些工作往往是<u>穿插</u>进行的
- 编译程序生成的目标程序，不一定是<u>机器语言的程序</u>。不一定是<u>可执行程序</u>
- 目标代码在形式上分为：<u>绝对指令代码、可重定位的指令代码、汇编指令代码</u>

### 第二章

- BNF范式是一种广泛采用的描述<u>语言和语法规则</u>的范式
- 一个语言的文法是<u>不唯一的</u>
- 生成非0开头的正偶数的文法
- 若一个文法是递归的，则它产生的句子的个数是无穷的
- 一个句型的最左简单短语或直接短语称为句柄
- 对任意一个左限性文法，<u>都存在</u>一个右限性文法使得二者等价
- 正规文法<u>不一定是</u>二义性文法(二者无关)
- ❌ 文法的规则的左部就是非终结符(比如0和1型)

### 第三章

- 确定的有穷自动机是<u>五元组</u>
- <u>不存在</u>这样一些语言，他们能被确定的有穷自动机识别，但不能被正规式表示

### 第四章

- 不确定的自顶向下的语法分析会遇到的问题：<u>回溯</u>
- LL（1）的两个 L 分别代表什么含义？$\rightarrow$ 老师说不会出这种题。但多记一个又怎么了！
    - 第一个L表明自顶向下分析时从左向右扫描输入串
    - 第二个L表明分析过程将最左推导
- 编译程序的语法分析程序接受<u>单词</u>的输入
- 递归下降子程序的语法分析属于<u>自顶向下</u>
- 表驱动的可以用递归下降
- LL(K)文法都是非二义性的文法

### 第五章

- 算符优先分析每次都是对<u>最左素短语</u>进行规约
- LR 语法分析栈中，存在的状态，是识别<u>可归前缀(活前缀)</u>的DFA
- 若一个句型中，出现了某一个产生式的右部，该右部不一定是句柄
- ✅ 一个文法是LR1文法，那么它一定是SLR1文法
- LR、SLR、LALR 的范围比较：
    - 最小 LR0
    - 中间 解决冲突用SLR1，不能都解决
    - 最大 的LR1
    - LALR1 比 LR1 小，但大小等于 SLR1
- 如果一个文法是 LR1，不一定是 LALR1，反之则一定是
- ❌ 符号表由词法分析程序建立，由语法分析程序使用
- 下列关于标识符和名字叙述中，正确的是<u>C</u>。
    - A、标识符有一定的含义  
    - B、名字是一个没有意义的字符串序列  
    - C、名字有确切的属性  
    - D、A~C都不正确  
- 过程和过程引用信息交换的方法是<u>参数传递</u>和<u>全局变量使用</u>
- 允许动态申请和释放空间，采用的存储分配的技术是<u>堆</u>
- Pascal中过程说明的局部变量地址分配在<u>B</u>。
    - A. 调用者的数据区中
    - C. 被调用者的数据区中
    - C. 主程序的数据区中
    - D. 公共数据区中

## 🔥 题目分布<!-- markmap: fold -->

### 第二章

- 【大题】给文法，问语言。或反之
- 【大题】语法树进行语法分析，找最左素短语

### 第三章

- 【大题】NFA 的确定化、最小化

### 第四章

- 【大题】给文法、是否 LL(1)
- 【大题】表驱动方法分析句子

## 13 🔥 我的错题本<!-- markmap: fold -->